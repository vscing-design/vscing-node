<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>{{.title}}</title>
  </head>

  <body>
    输出文本：{{.desc}}
    <div>hello golang</div>

    <input type="file" id="fileInput" />
  </body>
  <script> // 创建 fps 面板展示元素
      var fpsPanel = document.createElement("div");
      fpsPanel.setAttribute("id", "fps");
      fpsPanel.style.position = "fixed";
      fpsPanel.style.left = "3px";
      fpsPanel.style.top = "3px";
      fpsPanel.style.color = "red";
      fpsPanel.style.zIndex = 10000;
      // 将面板插入到 body
      document.body.append(fpsPanel);
      // fps 监测逻辑实现
      var showFPS = (function () {
        var requestAnimationFrame =
          window.requestAnimationFrame ||
          window.webkitRequestAnimationFrame ||
          window.mozRequestAnimationFrame ||
          window.oRequestAnimationFrame ||
          window.msRequestAnimationFrame ||
          function (callback) {
            window.setTimeout(callback, 1000 / 60);
          };
        var e, pe, pid, fps, last, offset, step, appendFps;

        fps = 0;
        last = Date.now();
        step = function () {
          offset = Date.now() - last;
          fps += 1;
          if (offset >= 1000) {
            last += offset;
            appendFps(fps);
            fps = 0;
          }
          requestAnimationFrame(step);
        };
        appendFps = function (fps) {
          // 打印 fps
          console.log(fps + "FPS");
          // 修改面板显示的值
          fpsPanel.innerHTML = fps + "FPS";
        };
        step();
      })(); </script>
  <script>
    function parseBookmarks(bookmarksHtml) {
      const parser = new DOMParser();
      const root = parser.parseFromString(bookmarksHtml, "text/html");
      const result = [];
      walkBookmarksTree(root, result);
      console.log('%c [ result ]-22', 'font-size:13px; background:pink; color:#bf2c9f;', result)
    }

    function walkBookmarksTree(root, result) {
        let node = root.querySelector("dl");
        let els = node.children;
        if (els && els.length > 0) {
            for (let i = 0; i < els.length; i++) {
                let item = els[i];
                // p标签直接跳过
                if (item.tagName === "P") {
                    continue;
                }
                // dt标签
                if (item.tagName === "DT") {
                    let h3Node = item.querySelector("h3");
                    let aNode = item.querySelector("a");
                    let dlNode = item.querySelector("dl");
                    let child = null;
                    if(h3Node && dlNode) {
                        child = {
                            name: h3Node.innerText ?? "",
                            folder: true,
                            addDate: h3Node.getAttribute("add_date"),
                            lastModified: h3Node.getAttribute("last_modified"),
                            children: [],
                        };
                        walkBookmarksTree(item, child.children);
                        result.push(child);
                    } else if(aNode) {
                        result.push({
                            name: aNode.innerText ?? "",
                            url: aNode.href ?? "",
                            addDate: aNode.getAttribute("add_date") ?? "",
                            icon: aNode.getAttribute("icon") ?? "",
                        })
                    }
                }
            }
        }
        return result;
    }   

    parseBookmarks(localStorage.getItem('yeqian'));

    document
      .getElementById("fileInput")
      .addEventListener("change", function (event) {
        const file = event.target.files[0];
        if (!file) {
          return;
        }

        const reader = new FileReader();
        reader.onload = function (e) {
          const contents = e.target.result;
          console.log('%c [ contents ]-96', 'font-size:13px; background:pink; color:#bf2c9f;', contents)
          localStorage.setItem('yeqian', contents);
        //   console.log(parseBookmarks(contents)); // 输出文件内容
          // 你可以在这里进一步解析HTML内容
        };
        reader.onerror = function (e) {
          console.error("File could not be read! Code " + e.target.error.code);
        };

        reader.readAsText(file); // 读取文件内容为文本
      });

    // webwork 处理数据
    // 解析数据
    // indexdb 存储数据
    // 不支持的情况处理
  </script>
</html>
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Draggable Tree Example</title>
    <style>
      #tree {
        width: 300px;
        border: 1px solid #ccc;
        padding: 10px;
      }
      #tree [data-id] {
        border: 1px dashed #ccc;
        padding: 5px;
        margin-top: 5px;
        cursor: move;
      }
      #tree [data-level="2"] {
        margin-left: 20px;
      }
      #tree [data-level="3"] {
        margin-left: 30px;
      }
      #tree [data-level="4"] {
        margin-left: 40px;
      }
      #tree [data-level="5"] {
        margin-left: 50px;
      }
      #tree .drag-highlight {
        position: relative;
        background: #4e71f2;
      }
      #tree .drag-border-top {
        border-top-color: red;
      }
      #tree .drag-border-bottom {
        border-bottom-color: red;
      }
    </style>
  </head>
  <body>
    <div id="tree" draggable="false"></div>

    <script>
      // 维护一个展开状态的对象
      const expandedNodes = {};

      const treeData = [
        {
          id: 1,
          title: "Node 1",
          children: [
            {
              id: 2,
              title: "Node 1.1",
              children: [],
            },
            {
              id: 3,
              title: "Node 1.2",
              children: [],
            },
          ],
        },
        {
          id: 4,
          title: "Node 2",
          children: [
            {
              id: 5,
              title: "Node 2.1",
              children: [],
            }
          ],
        },
        {
          id: 6,
          title: "Node 3",
          children: [],
        },
      ];

      // 获取树的容器
      const treeContainer = document.getElementById("tree");

      // 事件
      const onMousemove = (event) => {
      }

      let draggedElement = null;

      // 开始拖拽一个元素或选中的文本时触发
      const onDragstart = (event) => {
        draggedElement = event.target;
        // 另一种方法是将属性存储在元素的自定义属性中
        const attributes = {};
        Array.from(event.target.attributes).forEach(attr => {
          attributes[attr.name] = attr.value;
        });
        // 使用dataTransfer.setData来存储整个对象
        event.dataTransfer.setData('application/json', JSON.stringify(attributes));
      }

      // 当拖拽元素或选中的文本到一个可释放目标时触发
      const onDragenter = (event) => {
        // 移除所有同级元素的辅助线
        // const siblings = event.target.parentNode.children;
        // for (let sibling of siblings) {
        //   sibling.classList.remove('drag-highlight');
        // }
        // 添加辅助线
        

        // event.target.attributes["data-id"] || 
        // if(!event.target.contains(event.relatedTarget)) {
        //   event.target.classList.add('drag-highlight');
        // }
        // 阻止默认行为以允许放置
        event.preventDefault();
      }

      // 当元素或选中的文本被拖到一个可释放目标上时触发（每 100 毫秒触发一次）。
      const onDragover = (event) => {
        // 阻止默认行为以允许放置
        event.preventDefault();
        const { clientX, clientY } = event;
        const currElm = event.target.getBoundingClientRect();

        // 判断鼠标位置并添加相应的样式
        if(clientY < currElm.top + 5) {
          event.target.classList.remove('drag-highlight'); // 移除背景色
          event.target.classList.add('drag-border-top'); // 添加上边框
          event.target.classList.remove('drag-border-bottom'); // 移除下边框
        } else if (clientY > currElm.top + currElm.height - 5) {
          event.target.classList.remove('drag-highlight'); // 移除背景色
          event.target.classList.remove('drag-border-top'); // 移除上边框
          event.target.classList.add('drag-border-bottom'); // 添加下边框
        } else if(clientY > currElm.top && clientY < currElm.top + currElm.height) {
          event.target.classList.add('drag-highlight'); // 在中间时添加背景色
          event.target.classList.remove('drag-border-top'); // 移除上边框
          event.target.classList.remove('drag-border-bottom'); // 移除下边框
        }
      }

      // 当拖拽元素或选中的文本离开一个可释放目标时触发。
      const onDragleave = (event) => {
        // 阻止默认行为以允许放置
        event.preventDefault();
        // 移除元素的辅助线
        event.target.classList.remove('drag-highlight');
        event.target.classList.remove('drag-border-top');
        event.target.classList.remove('drag-border-bottom');
        // 移除所有同级元素的辅助线
        // const siblings = event.target.parentNode.children;
        // for (let sibling of siblings) {
        //   sibling.classList.remove('drag-highlight');
        // }
      }

      // 当元素或选中的文本在可释放目标上被释放时触发
      const onDrop = (event) => {
        // 阻止默认行为
        event.preventDefault();

        // console.log('%c [ event ]-127', 'font-size:13px; background:pink; color:#bf2c9f;', event)
        // 获取被拖动的节点
        const data = event.dataTransfer.getData('application/json');
        const attributes = JSON.parse(data);

        const targetElement = event.target;

        // 这里可以添加逻辑来处理拖动元素的放置 将拖动的元素移动到目标元素的位置
        if (targetElement !== draggedElement) {
          targetElement.parentNode.insertBefore(draggedElement, targetElement);
        }
      }

      // 当拖拽操作结束时触发 (比如松开鼠标按键或敲“Esc”键)
      const onDragend = (event) => {
        // 阻止默认行为
        event.preventDefault();
      }

      function createNodeElement(nodeData) {
        const element = document.createElement("div");
        element.setAttribute("draggable", true);
        element.setAttribute("data-id", nodeData.id);
        element.setAttribute("data-level", nodeData.level);
        element.textContent = nodeData.title;
        // 将原始数据存储在元素上，以便后续操作
        element.nodeData = nodeData;
        // 添加事件监听器
        element.addEventListener('mousemove', onMousemove);
        element.addEventListener('dragstart', onDragstart);
        element.addEventListener('dragenter', onDragenter);
        element.addEventListener('dragover', onDragover);
        element.addEventListener('dragleave', onDragleave);
        element.addEventListener('drop', onDrop);
        element.addEventListener('dragend', onDragend);

        treeContainer.appendChild(element);
        
        // 递归创建子节点
        if (nodeData.children.length > 0) {
          nodeData.children.forEach((child) => {
            createNodeElement({
              ...child,
              level: nodeData.level + 1
            })
          });
        }
      }

      // 将树形结构渲染到页面上
      treeData.forEach((node, index) => {
        createNodeElement({
          ...node,
          level: 1
        })
      });

      // treeContainer.addEventListener("dragenter", function (event) {
      //   console.log('%c [ dragenter ]-206', 'font-size:13px; background:pink; color:#bf2c9f;')
      //   event.preventDefault();
      // });
    </script>
  </body>
</html>
